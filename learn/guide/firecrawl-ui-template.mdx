---
title: "Web Connector UI 模板"
description: "使用 Firecrawl 和 React 设置网页数据抓取的 UI 指南。"
og:title: "Web Connector UI 模板 | Firecrawl"
og:description: "了解如何使用 Firecrawl 和 React 设置网页数据抓取的 UI。"
---

> 注意：此示例使用的是 [v0 版本的 Firecrawl API](/v0/introduction)。您可以安装 Python SDK 的 0.0.20 版本或 Node SDK 的 0.0.36 版本。

此模板简化了使用 React 为 Firecrawl 创建网页连接器 UI 的过程。
它包括一个预构建的组件，该组件与 Firecrawl API 交互，使您能够快速为用户设置一个网页抓取和解析界面，以便为他们提取 AI 应用程序的数据。
![Firecrawl UI 模板](/images/firecrawl-ui.png)

此模板允许用户输入要抓取的 URL。如果检测到子页面，模板将抓取它们并显示发现的 URL 列表。然后用户可以选择要抓取哪些 URL，抓取的内容将被摄入他们的 AI 应用并在 UI 中显示。
> **安全考虑：此示例在客户端代码中暴露了 Firecrawl API 密钥。为了生产环境，强烈建议将 API 交互转移到服务器端实现以保护您的 API 密钥。**

## 先决条件

- Node.js（推荐 v14 或更高版本）
- npm
- 确保已安装 [shadcn](https://github.com/shadcn-ui/ui)
- 确保已安装 [tailwindcss](https://tailwindcss.com/docs/installation)

## 开始使用

1. 安装依赖项：

- 安装所需的 [shadcn 组件](https://github.com/shadcn-ui/ui)：
```
npx shadcn-ui@latest add button card checkbox collapsible input label
```

- 安装其余依赖项：
```
npm install clsx lucide-react tailwind-merge tailwindcss-animate class-variance-authority
```

2. 创建一个 `lib/utils.ts` 文件并添加以下代码：

```typescript
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
```

3. 复制并粘贴我们的主要获取组件。**请确保将 `FIRECRAWL_API_KEY` 替换为您的密钥。**

<Accordion title="获取组件 (ingestion.tsx)">
```jsx
import { useState, ChangeEvent, FormEvent, useEffect } from "react";
import {
  Card,
  CardHeader,
  CardTitle,
  CardContent,
  CardFooter,
} from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Checkbox } from "@/components/ui/checkbox";
import { Label } from "@/components/ui/label";
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from "@/components/ui/collapsible";
import { ChevronDown, ChevronLeft, ChevronRight } from "lucide-react";

//! 硬编码值（不推荐用于生产）
//! 强烈建议将所有 Firecrawl API 调用移到后端（例如 Next.js API 路由）
const FIRECRAWL_API_URL = "https://api.firecrawl.dev"; // 替换为您的实际 API URL，无论它是本地的还是使用 Firecrawl Cloud
const FIRECRAWL_API_KEY = "fc-YOUR_API_KEY"; // 替换为您的实际 API 密钥

interface FormData {
  url: string;
  crawlSubPages: boolean;
  limit: string;
  maxDepth: string;
  excludePaths: string;
  includePaths: string;
  extractMainContent: boolean;
}

interface CrawlerOptions {
  includes?: string[];
  excludes?: string[];
  maxDepth?: number;
  limit?: number;
  returnOnlyUrls: boolean;
}

interface PageOptions {
  onlyMainContent: boolean;
}

interface RequestBody {
  url: string;
  crawlerOptions?: CrawlerOptions;
  pageOptions: PageOptions;
}

interface ScrapeResultMetadata {
  title: string;
  description: string;
  language: string;
  sourceURL: string;
  pageStatusCode: number;
  pageError?: string;
  [key: string]: string | number | undefined;
}

interface ScrapeResultData {
  markdown: string;
  content: string;
  html: string;
  rawHtml: string;
  metadata: ScrapeResultMetadata;
  llm_extraction: Record<string, unknown>;
  warning?: string;
}

interface ScrapeResult {
  success: boolean;
  data: ScrapeResultData;
}

export default function FirecrawlComponent() {
  const [formData, setFormData] = useState<FormData>({
    url: "",
    crawlSubPages: false,
    limit: "",
    maxDepth: "",
    excludePaths: "",
    includePaths: "",
    extractMainContent: false,
  });
  const [loading, setLoading] = useState<boolean>(false);
  const [scrapingSelectedLoading, setScrapingSelectedLoading] =
    useState<boolean>(false);
  const [crawledUrls, setCrawledUrls] = useState<string[]>([]);
  const [selectedUrls, setSelectedUrls] = useState<string[]>([]);
  const [scrapeResults, setScrapeResults] = useState<
    Record<string, ScrapeResult>
    >({});
  const [isCollapsibleOpen, setIsCollapsibleOpen] = useState(true);
  const [crawlStatus, setCrawlStatus] = useState<{
    current: number;
    total: number | null;
    }>({ current: 0, total: null });
  const [elapsedTime, setElapsedTime] = useState<number>(0);
  const [showCrawlStatus, setShowCrawlStatus] = useState<boolean>(false);
  const [isScraping, setIsScraping] = useState<boolean>(false);
  const [currentPage, setCurrentPage] = useState<number>(1);
  const urlsPerPage = 10;

  useEffect(() => {
    let timer: NodeJS.Timeout;
    if (loading) {
      setShowCrawlStatus(true);
      timer = setInterval(() => {
        setElapsedTime((prevTime) => prevTime + 1);
      }, 1000);
    }
    return () => {
      if (timer) clearInterval(timer);
    };
  }, [loading]);

  const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
    const { name, value, type, checked } = e.target;
    setFormData((prevData) => ({
      ...prevData,
      [name]: type === "checkbox" ? checked : value,
    }));
  };

  const handleSubmit = async (e: FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setLoading(true);
    setIsCollapsibleOpen(false);
    setElapsedTime(0);
    setCrawlStatus({ current: 0, total: null });
    setIsScraping(!formData.crawlSubPages);
    setCrawledUrls([]);
    setSelectedUrls([]);
    setScrapeResults({});
    setScrapingSelectedLoading(false);
    setShowCrawlStatus(false);

    try {
      const endpoint = `${FIRECRAWL_API_URL}/v0/${
        formData.crawlSubPages ? "crawl" : "scrape"
      }`;

      const requestBody: RequestBody = formData.crawlSubPages
        ? {
            url: formData.url,
            crawl